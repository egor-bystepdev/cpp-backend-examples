# Immutable vector

В предыдущих задачах мы уже реализовывали много разных стандартных структур, такие как вектор, список и т.д.. В этой задаче мы
познакомимся с другим классом структур, которые обычно используются в функциональных языках, таких как Haskell, Scala и других.

А именно, там широко используются _иммутабельные_ (неизменяемые) структуры данных. В такой структуре
любая "изменяющая" операция не модифицирует исходную структуру, а возвращает новую с примененными изменениями. Например, рассмотрим обычный массив `a`.
Операция `a.set(5, 3)` присвоит 5-ому элементу массива значение 3, тем самым изменив его. В иммутабельном массиве операция `a.set(5, 3)` возвращает новый
массив, в котором в 5-ом элементе записано значение 3, а остальные элементы такие же, как и в `a`, который остался без изменений.

Иммутабельность обычно подразумевает и _персистентность_ структуры данных, т.е. эффективную работу с различными версиями структуры. Действительно, поскольку все операции с иммутабельной структурой
возвращают ее новые версии, структура должна эффективно работать с этими версиями, иначе применение иммутабельности будет дорого обходиться. Разумеется, любую структуру можно сделать
иммутабельной, просто делая полную копию текущей структуры в каждой операции. Однако помимо того, что это неэффективно, хранение многих версий такой структуры вряд ли возможно.

При эффективной реализации иммутабельность имеет следующие плюсы:
1. Такую структуру легче использовать в многопоточном коде (в следующем семестре это станет ясно).
2. Все операции с такой структурой дают сильную гарантию на исключения, что естественно, т.к. нет модифицирующих структуру операций.
О различных гарантиях можно почитать [здесь](https://en.wikipedia.org/wiki/Exception_safety).
3. Иммутабельность дает и версионируемость, а значит можно эффективно откатывать структуру в более ранние состояния, делать снимок текущего состояния.

В этой задаче вам предстоит реализовать упрощенный аналог контейнера `scala.collection.immutable.Vector`
